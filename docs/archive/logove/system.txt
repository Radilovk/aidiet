Това е пълният технически "post-mortem" на процеса, базиран на логовете. Анализът е без филтър, фокусиран върху архитектурните дефекти, замърсяването на данните (data pollution) и логическия срив.

### ЧАСТ 1: ПЪЛЕН СПИСЪК НА ГРЕШКИТЕ И ШУМА (DIAGNOSTIC REPORT)

Системата се проваля в три направления: **Типове данни (Backend/Frontend Conflict)**, **Математическа логика** и **Контекстуална памет**.

#### 1. "Dirty Data" & Frontend Bloat (Замърсяване и Шум)

Това са грешките, които чупят кода или правят JSON-а неизползваем без тежка обработка.

* **Mixed Types in Numeric Fields (Критично):**
* *Грешка:* `bmr: "1395 kcal (изчислен от backend)"`
* *Проблем:* Полето `bmr` трябва да е `Int` или `Float`. Вкарването на стринг с дименсия ("kcal") и обяснение в скоби прави невъзможно математическото му използване от фронтенда без RegEx почистване.


* **Narrative in Data Fields:**
* *Грешка:* `protein: "30% - Увеличеният прием... е важен за kakadu..."`
* *Проблем:* Вместо стойност (`0.30` или `30`), се връща цяло есе. Това пречи на визуализацията (напр. Pie Chart).


* **Visual Formatting in Logical Structure:**
* *Грешка:* `name: "• Салата...\n• Пиле..."`
* *Проблем:* Бекендът "рисува" вместо фронтенда. Булетите (`•`) и новите редове (`\n`) са презентация, не данни. Това заключва UI към един единствен вид визуализация.


* **Redundant Content (Token Waste):**
* *Грешка:* Полето `benefits` във всяко едно ястие (над 21 пъти за седмицата).
* *Проблем:* Генерични фрази тип "Богато на витамини", които потребителят спира да чете след втория ден. Това увеличава размера на JSON-а с ~30% без добавена стойност.
* *Грешка:* Полето `welcomeMessage` в Step 2 – чист маркетинг, който трябва да е статичен текст в приложението, а не генериран от скъп AI модел.



#### 2. Математически и Логически Срив

* **The "Target vs Reality" Gap:**
* *Цел:* 1838 kcal (Step 1).
* *Резултат:* 1367 kcal (Step 4 Summary).
* *Дефект:* Системата отчита 500 калории дефицит като нормален резултат. Това е грешка в алгоритъма за самоконтрол.


* **Ingredient Hallucinations:**
* *Пример:* Леща (300g) + Салата = 420 kcal (Step 3).
* *Реалност:* Това е физически невъзможно. 300g сготвена леща е ~350 kcal, добави зехтин и става 500+. AI налучква числата, за да паснат на око.


* **Structural Amnesia (Липса на памет):**
* *Step 1:* "Клиентът не закусва" (Flags: Skip Breakfast).
* *Step 3 (Day 1):* Няма закуска (Спазва логиката).
* *Step 3 (Day 3):* Има закуска (Забравя логиката).
* *Step 3 (Day 7):* Няма закуска (Отново се връща, или просто го мързи).
* *Извод:* Всеки чанк (Chunk) работи като отделна вселена, без да знае правилата на другите.



---

### ЧАСТ 2: РЕШЕНИЕТО – "THE MASTER BLUEPRINT" (СТРАТЕГИЯ В ПЪРВИ ПРОМПТ)

За да се оправи това, трябва да преместиш **цялата изчислителна логика в Step 1**. В момента Step 1 е "анализатор на текст". Трябва да стане "Архитект на база данни".

Ето как трябва да се структурира първият промпт и неговият отговор, за да служи като **Твърд Закон** за всички следващи стъпки.

#### 1. Новият Prompt за Step 1 (Концепция)

> "Ти си **System Architect** за диетологичен софтуер.
> 1. Анализирай потребителя.
> 2. Изчисли ТОЧНИТЕ калории и макроси (само числа).
> 3. Създай **Седмична Матрица (Grid)**. За всеки ден от 1 до 7 определи:
> * Дали има закуска (true/false).
> * Точен калориен таргет за всяко хранене (напр. Обяд: 650 kcal).
> * Основен протеинов източник (за да няма повторения).
> 
> 
> 4. Върни **Strict JSON** без никакъв текст в числовите полета."
> 
> 

#### 2. The Clean JSON Output (Това трябва да получиш от Step 1)

Този JSON става "Конституция". Следващите стъпки (Meal Gen) нямат право да мислят, те само изпълняват този план.

```json
{
  "user_config": {
    "daily_target_kcal": 1838,
    "macro_split_g": { "p": 135, "c": 160, "f": 70 }, 
    "diet_type": "mediterranean"
  },
  "global_rules": {
    "skip_breakfast": true,
    "hydration_target_l": 2.5
  },
  "weekly_blueprint": [
    {
      "day_index": 1,
      "structure_type": "2_meals_intermittent",
      "slots": {
        "breakfast": { "active": false, "kcal_target": 0 },
        "lunch": { 
            "active": true, 
            "kcal_target": 900, 
            "protein_source_constraint": "chicken", 
            "carb_source_constraint": "quinoa"
        },
        "dinner": { 
            "active": true, 
            "kcal_target": 938, 
            "protein_source_constraint": "salmon", 
            "carb_source_constraint": "leafy_greens"
        },
        "snack": { "active": false, "kcal_target": 0 }
      }
    },
    {
      "day_index": 2,
      "structure_type": "3_meals_standard", 
      "slots": {
        "breakfast": { "active": true, "kcal_target": 400, "constraint": "oats_yogurt" },
        "lunch": { "active": true, "kcal_target": 700, "constraint": "lentils" },
        "dinner": { "active": true, "kcal_target": 738, "constraint": "eggs_avocado" }
      }
    }
    // ... повтаря се за 7 дни
  ]
}

```

### ЧАСТ 3: КАК ТАЗИ СТРАТЕГИЯ РЕШАВА ВСИЧКО?

1. **Премахва Шума:** Няма маркетингови текстове. Фронтендът получава чисти данни (`day_index: 1`, `kcal_target: 900`).
2. **Оправя Математиката:** Сборът на `kcal_target` в Blueprint-а винаги ще е равен на 1838, защото се смята на едно място (Step 1), преди да се намесят рецептите.
3. **Оправя "Амнезията":** Когато Step 3 (Meal Gen) тръгне да генерира Ден 5, той гледа Blueprint-а и вижда: *"Аха, днес трябва да е 'White Fish', 600 kcal"*. Няма нужда да помни какво е било вчера, защото планът е начертан.
4. **Фронтенд Съвместимост:** Типовете са `Boolean`, `Integer`, `String` (enum). Няма нужда от regex, split или чистене на булети.

**Препоръка за незабавно действие:**
Промени промпта на **Step 1**, така че да не връща "анализ" (есе), а "архитектура" (този JSON горе). Всички останали стъпки (2, 3, 4) трябва просто да консумират този JSON и да попълват празните полета с рецепти.