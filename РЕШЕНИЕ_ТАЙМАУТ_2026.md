# Решение на проблема с таймаут при генериране на план

## Проблем
Потребителите получават грешка "Заявката отне твърде дълго време. Моля, проверете интернет връзката и опитайте отново." при генериране на хранителен план.

## Открити Причини

### 1. Непоследователни настройки на таймаут ✅ ПОПРАВЕНО

**Проблем:**
- `questionnaire.html` използва 120-секунден таймаут
- `profile.html` използва само 60-секунден таймаут
- `test.html` няма таймаут изобщо

**Въздействие:**
При регенериране на план от страницата с профил, таймаутът от 60 секунди е твърде кратък за 3-стъпковия AI процес.

**Решение:**
Всички файлове сега използват еднакъв 120-секунден таймаут.

### 2. Многостъпковото генериране отнема време (Очаквано поведение)

Приложението използва **3-стъпков AI подход** за максимална прецизност:

1. **Стъпка 1:** Здравен анализ (~20-40 секунди)
2. **Стъпка 2:** Генериране на стратегия (~20-40 секунди)
3. **Стъпка 3:** Създаване на хранителен план (~30-60 секунди)
4. **Валидация:** Валидиране на плана + евентуални корекции (~10-30 секунди ако е нужно)

**Общо очаквано време:** 70-170 секунди при нормални условия

По време на пиково натоварване или със закъснения от API, това може да наближи или надхвърли 120 секунди.

### 3. Ограничения на Cloudflare Worker ✅ ПОПРАВЕНО

Cloudflare Workers имат различни лимити за време на изпълнение:

| План | CPU Time Limit | Wall-Clock Time Limit |
|------|----------------|----------------------|
| Безплатен | 10ms | ~30 секунди* |
| Платен | 50ms | ~30 секунди* |
| Unbound Workers | 30 секунди | Без твърд лимит |

**Важно:** Външните API повиквания (OpenAI, Gemini) не се броят към CPU времето, но се броят към wall-clock времето.

**Предишен статус:** Приложението използваше стандартни workers, причинявайки таймаути на ~30 секунди (40-50% прогрес).

**Настоящ статус:** **Unbound Workers е сега активиран** в `wrangler.toml`, премахвайки wall-clock time лимита и позволявайки пълния многостъпков AI процес на генериране (70-170 секунди) да завърши успешно.

## Направени Промени

### Frontend Промени

#### questionnaire.html
1. **Подобрено логване:**
   - Проследяване на началното време на заявката
   - Логване на продължителността на заявката
   - Логване на размера на полезния товар
   - По-добра категоризация на грешките

2. **Подобрена обработка на грешки:**
   - Разграничаване между таймаут, мрежови и сървърни грешки
   - Показване на подходящи съобщения за грешка
   - Логване на подробна информация за грешката за debugging

3. **Правилно почистване:**
   - Използване на try-finally блокове за гарантиране, че таймаутите винаги се изчистват

#### profile.html
1. **Увеличен таймаут:** 60s → 120s
2. **Подобрено логване:** Същото като questionnaire.html
3. **Подобрена обработка на грешки:** Същото като questionnaire.html
4. **Правилно почистване:** try-finally блокове

#### test.html
1. **Добавен 120-секунден таймаут** (преди нямаше)
2. **Добавена обработка на грешки при таймаут**
3. **Консистентен с продукционния код**

### Backend Промени

**Не са нужни промени** - Backend-ът вече има:
- Логика за повторни опити с експоненциално забавяне (3 опита)
- Правилна обработка на грешки
- Подробно логване
- Валидация с автоматични корекции

### Документация

#### TIMEOUT_FIX_2026.md (НОВА)
Цялостна документация с:
- Анализ на основните причини
- Всички идентифицирани причини за таймаут
- Решения и препоръки
- Ръководство за мониторинг
- Препоръки за тестване

#### wrangler.toml
Добавени бележки за:
- Cloudflare Worker лимити
- Инструкции за активиране на Unbound Workers

## Как да тествате

### 1. Проверете продължителността на заявката

Отворете DevTools Console в браузъра и търсете:
```
Sending request to backend...
Request payload size: XXXX bytes
Response received after XX.X seconds with status: 200
```

**Нормално:** 70-120 секунди  
**Загрижващо:** >120 секунди (може да изтече)  
**Проблем:** <10 секунди с грешка (мрежов или сървърен проблем)

### 2. Проверете за специфични грешки

| Тип грешка | Съобщение в Console | Вероятна причина |
|------------|---------------------|------------------|
| Timeout | "Request timeout after..." | Многостъпковото изпълнение отне >120s |
| Network | "Failed to fetch" | Проблем с връзката |
| Server | "Server error: 500" | Грешка в backend |
| Rate Limit | "429 Too Many Requests" | API rate limit |

### 3. Тествайте в различно време

- **Пикови часове** (обяд, вечер): По-големи закъснения от API
- **Извън пиковите часове** (рано сутрин): По-бързи отговори

## Препоръки за потребителите

Ако видите грешка за таймаут:

1. **Изчакайте 2-3 минути** - AI-ят анализира вашия профил задълбочено
2. **Проверете интернет връзката** - Уверете се, че имате стабилна връзка
3. **Опитайте отново** - Временните закъснения от API може да се разрешат
4. **Опитайте в различно време** - Извън пиковите часове е по-бързо

### Очаквани времена за изчакване

- **Нормално:** 1-2 минути
- **Пикови часове:** 2-3 минути
- **Първа заявка:** Може да е по-бавна (моделът се загрява)

## Следващи стъпки (Опционално)

### Краткосрочни
1. ✅ **Увеличаване на frontend таймаут** (ГОТОВО)
2. ✅ **Добавяне на подробно логване** (ГОТОВО)
3. ✅ **Активиране на Unbound Workers** (ГОТОВО - Януари 2026)
4. Наблюдавайте логовете, за да идентифицирате останали проблеми

### Средносрочни
1. ~~**Надстройте до Unbound Workers** ако таймаутите продължават~~ ✅ **ГОТОВО** (Януари 2026)
   - Премахва wall-clock time лимита
   - Позволява заявки >30 секунди
   - Цена: Базирана на CPU време + продължителност

2. **Оптимизирайте API повикванията** (ако е нужно)
   - Използвайте по-бързи модели (gpt-3.5-turbo вместо gpt-4)
   - Намалете размерите на промптовете
   - Кеширайте общи анализи

### Дългосрочни
1. **Внедрете кеширане**
   - Кеширайте анализи за подобни профили
   - Преизползвайте стратегии когато е уместно

2. **Базирана на опашка обработка**
   - Приемете заявката веднага
   - Обработвайте на заден план
   - Уведомете потребителя когато е готово

## Техническа информация

### Логика за Frontend Timeout

```javascript
const controller = new AbortController();
const startTime = Date.now();
const timeoutId = setTimeout(() => {
    const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(1);
    console.error(`Request timeout after ${elapsedTime} seconds (limit: 120 seconds)`);
    controller.abort();
}, 120000);

try {
    // Изпълнение на заявката
} finally {
    clearTimeout(timeoutId); // Винаги се почиства
}
```

### Категоризация на грешки

```javascript
if (error.name === 'AbortError') {
    // Frontend таймаут - заявката надхвърли 120 секунди
} else if (error.message.includes('Failed to fetch')) {
    // Мрежова грешка - проблем с връзката
} else if (error.message.includes('Server error')) {
    // Backend грешка - worker или API проблем
}
```

## Обобщение

Грешката за таймаут може да има множество причини:

1. ✅ **Непоследователност във frontend таймаута** - ПОПРАВЕНО
2. ⚠️ **Очаквано поведение** - Многостъпковият AI отнема 70-120+ секунди
3. ✅ **Cloudflare Worker лимити** - ПОПРАВЕНО (Unbound Workers активиран Януари 2026)
4. ⚠️ **API rate limiting** - Временни закъснения от OpenAI/Gemini
5. ⚠️ **Мрежови проблеми** - Истински проблеми с връзката

Подобреното логване ще помогне за идентифициране на останали проблеми в продукция.

## Референции

- [Cloudflare Workers Лимити](https://developers.cloudflare.com/workers/platform/limits/)
- [OpenAI Rate Limits](https://platform.openai.com/docs/guides/rate-limits)
- [Gemini API Limits](https://ai.google.dev/gemini-api/docs/quota)
- [CORS_FIX_NOTES.md](./CORS_FIX_NOTES.md) - Предишна поправка на таймаут
- [TIMEOUT_FIX_2026.md](./TIMEOUT_FIX_2026.md) - Цялостна техническа документация (на английски)
